# ========= Copyright 2023-2024 @ CAMEL-AI.org. All Rights Reserved. =========
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ========= Copyright 2023-2024 @ CAMEL-AI.org. All Rights Reserved. =========

import json
from typing import List, Optional

from camel.logger import get_logger
from camel.toolkits import FunctionTool
from camel.toolkits.base import BaseToolkit

logger = get_logger(__name__)


class MedCalcToolkit(BaseToolkit):
    def __init__(
        self,
        default_variable: str = "x",
        timeout: Optional[float] = None,
    ):
        r"""Initializes the toolkit with a default variable and optional
        timeout.

        Args:
            default_variable (str): The default variable used in symbolic
                computations (default: :obj:`x`).
            timeout (Optional[float]): The maximum time allowed for each
                computation (in seconds). If `None`, no timeout is enforced.
        """
        super().__init__(timeout=timeout)
        self.default_variable = default_variable
        logger.info(f"Default variable set to: {self.default_variable}")

    def adjusted_body_weight(
        self,
        weight_value: float,  # Numeric part of the weight (e.g., 89)
        weight_unit: str,  # Unit of the weight (e.g., "kg")
        height_value: float,  # Numeric part of the height (e.g., 163)
        height_unit: str,  # Unit of the height (e.g., "cm")
        sex: str,  # Gender ("male"/"female")
        age: int,  # Age
    ) -> str:
        r"""Calculate the patient's Adjusted Body Weight (ABW) and generate a
        detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of the
                following:
                - "lbs" for pounds.
                - "g" for grams.
                - "kg" for kilograms.
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of the
                following:
                - "cm" for centimeters.
                - "in" for inches.
            sex (str): The patient's gender, one of the following:
                - "Male" for male.
                - "Female" for female.
            age (int): The patient's age (integer). Currently unused but may
                be used for future extensions.

        Returns:
            str: A JSON string containing the calculation process and result,
                ormatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Adjusted body weight in kilograms (string
                        format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `abw_explanation` function is used to calculate the adjusted
                body weight.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
            - If the input gender is not "male" or "female", the function will
                not calculate IBW and ABW.
        """
        # Construct the input variables dictionary
        input_variables = {
            "weight": (
                float(weight_value),
                str(weight_unit),
            ),  # Weight: (value, unit)
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
            "sex": str(sex),  # Gender
            "age": int(age),  # Age
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.adjusted_body_weight import (
            abw_explanation,
        )

        try:
            # Call the ABW calculation function
            result = abw_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("abw_explanation", e)

    def anion_gap(
        self,
        sodium_value: float,  # Numeric part of the sodium level (e.g., 140.0)
        sodium_unit: str,  # Unit of the sodium level (e.g., "mEq/L")
        # Numeric part of the chloride level (e.g., 106.0)
        chloride_value: float,
        chloride_unit: str,  # Unit of the chloride level (e.g., "mEq/L")
        # Numeric part of the bicarbonate level (e.g., 20.0)
        bicarbonate_value: float,
        bicarbonate_unit: str,  # Unit of the bicarbonate level (e.g., "mEq/L")
    ) -> str:
        r"""Calculate the patient's Anion Gap and generate a detailed
        explanatory text.

        Args:
            sodium_value (float): The numeric value of the patient's sodium
                level.
            sodium_unit (str): The unit of the patient's sodium level, one of
                the following:
                - "mmol/L" for millimoles per liter.
                - "mEq/L" for milliequivalents per liter.
            chloride_value (float): The numeric value of the patient's
                chloride level.
            chloride_unit (str): The unit of the patient's chloride level, one
                of the following:
                - "mmol/L" for millimoles per liter.
                - "mEq/L" for milliequivalents per liter.
            bicarbonate_value (float): The numeric value of the patient's
                bicarbonate level.
            bicarbonate_unit (str): The unit of the patient's bicarbonate
                level, one of the following:
                - "mmol/L" for millimoles per liter.
                - "mEq/L" for milliequivalents per liter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Anion gap in mEq/L (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_anion_gap_explanation` function is used to
                calculate the anion gap.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (
                float(sodium_value),
                str(sodium_unit),
            ),  # Sodium: (value, unit)
            "chloride": (
                float(chloride_value),
                str(chloride_unit),
            ),  # Chloride: (value, unit)
            "bicarbonate": (
                float(bicarbonate_value),
                str(bicarbonate_unit),
            ),  # Bicarbonate: (value, unit)
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.anion_gap import (
            compute_anion_gap_explanation,
        )

        try:
            # Call the Anion Gap calculation function
            result = compute_anion_gap_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_anion_gap_explanation", e)

    def bmi_calculator(
        self,
        weight_value: float,  # Numeric part of the weight (e.g., 150)
        weight_unit: str,  # Unit of the weight (e.g., "lbs")
        height_value: float,  # Numeric part of the height (e.g., 170)
        height_unit: str,  # Unit of the height (e.g., "cm")
    ) -> str:
        r"""Calculate the patient's Body Mass Index (BMI) and generate a
        detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of the
                following:
                - "lbs" for pounds.
                - "g" for grams.
                - "kg" for kilograms.
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of the
                following:
                - "cm" for centimeters.
                - "in" for inches.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "BMI value (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `bmi_calculator_explanation` function is used to calculate
                the BMI.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "weight": (
                float(weight_value),
                str(weight_unit),
            ),  # Weight: (value, unit)
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.bmi_calculator import (
            bmi_calculator_explanation,
        )

        try:
            # Call the BMI calculation function
            result = bmi_calculator_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("bmi_calculator_explanation", e)

    def bsa_calculator(
        self,
        weight_value: float,  # Numeric part of the weight (e.g., 58.0)
        weight_unit: str,  # Unit of the weight (e.g., "kg")
        height_value: float,  # Numeric part of the height (e.g., 179.0)
        height_unit: str,  # Unit of the height (e.g., "cm")
    ) -> str:
        r"""Calculate the patient's Body Surface Area (BSA) and generate a
        detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of the
                following:
                - "lbs" for pounds.
                - "g" for grams.
                - "kg" for kilograms.
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of the
                following:
                - "cm" for centimeters.
                - "in" for inches.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Body Surface Area in square meters
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `bsa_calculator_explaination` function is used to calculate
                the body surface area.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "weight": (
                float(weight_value),
                str(weight_unit),
            ),  # Weight: (value, unit)
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.bsa_calculator import (
            bsa_calculator_explaination,
        )

        try:
            # Call the BSA calculation function
            result = bsa_calculator_explaination(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("bsa_calculator_explaination", e)

    def calcium_correction(
        self,
        # Numeric part of the albumin concentration (e.g., 4.0)
        albumin_value: float,
        albumin_unit: str,  # Unit of the albumin concentration (e.g., "g/dL")
        # Numeric part of the calcium concentration (e.g., 40)
        calcium_value: float,
        calcium_unit: str,  # Unit of the calcium concentration (e.g., "mg/L")
    ) -> str:
        r"""Calculate the patient's corrected calcium
            concentration and generate a detailed explanatory text.

        Args:
            albumin_value (float): The numeric value of the patient's
                albumin concentration.
            albumin_unit (str): The unit of the patient's albumin
                concentration, one of the following:
                - "g/L" for grams per liter.
                - "mg/dL" for milligrams per deciliter.
                - "g/mL" for grams per milliliter.
            calcium_value (float): The numeric value of the patient's
                calcium concentration.
            calcium_unit (str): The unit of the patient's calcium
                concentration, one of the following:
                - "g/L" for grams per liter.
                - "mg/dL" for milligrams per deciliter.
                - "g/mL" for grams per milliliter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Corrected calcium concentration in mg/dL
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `calculate_corrected_calcium_explanation` function is used
                to calculate the corrected calcium concentration.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "albumin": (
                float(albumin_value),
                str(albumin_unit),
            ),  # Albumin: (value, unit)
            "calcium": (
                float(calcium_value),
                str(calcium_unit),
            ),  # Calcium: (value, unit)
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.calcium_correction import (
            calculate_corrected_calcium_explanation,
        )

        try:
            # Call the corrected calcium calculation function
            result = calculate_corrected_calcium_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "calculate_corrected_calcium_explanation", e
            )

    def feverpain(
        self,
        symptom_onset: Optional[
            bool
        ],  # Whether the patient has a symptom onset ≤3 days
        purulent_tonsils: Optional[bool],  # Presence of pus on the tonsils
        fever_24_hours: Optional[
            bool
        ],  # Whether the patient has had a fever in the past 24 hours
        severe_tonsil_inflammation: Optional[
            bool
        ],  # Presence of severe tonsil inflammation
        cough_coryza_absent: Optional[bool],  # Absence of cough or coryza
    ) -> str:
        r"""Calculate the patient's FeverPAIN score and generate a detailed
        explanatory text.

        Args:
            symptom_onset (Optional[bool]): Whether the patient has a symptom
                onset ≤3 days.
            purulent_tonsils (Optional[bool]): Presence of pus on the tonsils.
            fever_24_hours (Optional[bool]): Whether the patient has had a
                fever in the past 24 hours.
            severe_tonsil_inflammation (Optional[bool]): Presence of
                severe tonsil inflammation.
            cough_coryza_absent (Optional[bool]): Absence of cough or coryza.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "FeverPAIN score (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_fever_pain_explanation` function is used to
                calculate the FeverPAIN score.
            - The `json.dumps` function is used to serialize the
                result into a JSON string.
            - If any of the input parameters are not provided,
                the function assumes the condition is absent.
        """
        # Construct the input variables dictionary
        input_variables = {
            "symptom_onset": symptom_onset,
            "purulent_tonsils": purulent_tonsils,
            "fever_24_hours": fever_24_hours,
            "severe_tonsil_inflammation": severe_tonsil_inflammation,
            "cough_coryza_absent": cough_coryza_absent,
        }
        print(input_variables)

        try:
            # Call the FeverPAIN score calculation function
            from camel.toolkits.medcalc_bench.feverpain import (
                compute_fever_pain_explanation,
            )

            result = compute_fever_pain_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_fever_pain_explanation", e)

    def heart_score(
        self,
        age_value: float,  # Numeric part of the age (e.g., 60)
        age_unit: str,  # Unit of the age (e.g., "years")
        hypertension: bool,  # History of hypertension (True/False)
        history: str,  # History of chest pain: "Slightly suspicious",
        # "Moderately suspicious", or "Highly suspicious"
        diabetes_mellitus: bool,  # Diabetes status (True/False)
        smoking: bool,  # Smoking history (True/False)
        # Family history of cardiovascular disease (True/False)
        family_with_cvd: bool,
        # History of atherosclerotic disease (True/False)
        atherosclerotic_disease: bool,
        initial_troponin: str,  # Initial troponin level:
        # "less than or equal to normal limit",
        # "between the normal limit or up to three times the normal limit", or
        # "greater than three times normal limit"
        # Electrocardiogram status: "Normal", "Non-specific repolarization
        # disturbance", or "Significant ST deviation"
        electrocardiogram: str,
        hypercholesterolemia: bool,  # Hypercholesterolemia status (True/False)
        obesity: bool,  # Obesity status (BMI > 30 kg/m²) (True/False)
    ) -> str:
        r"""Calculate the patient's HEART Score and generate a detailed
        explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age,
                one of the following:
                - "years" for years.
                - "months" for months.
            hypertension (bool): The patient's history of hypertension
                (True/False).
            history (str): The patient's history of chest pain,
                one of the following:
                - "Slightly suspicious".
                - "Moderately suspicious".
                - "Highly suspicious".
            diabetes_mellitus (bool): The patient's diabetes status
                (True/False).
            smoking (bool): The patient's smoking history (True/False).
            family_with_cvd (bool): The patient's family history of
                cardiovascular disease (True/False).
            atherosclerotic_disease (bool): The patient's history of
                atherosclerotic disease (True/False).
            initial_troponin (str): The patient's initial troponin level,
                one of the following:
                - "less than or equal to normal limit".
                - "between the normal limit or up to three times
                    the normal limit".
                - "greater than three times normal limit".
            electrocardiogram (str): The patient's electrocardiogram status,
                one of the following:
                - "Normal".
                - "Non-specific repolarization disturbance".
                - "Significant ST deviation".
            hypercholesterolemia (bool): The patient's hypercholesterolemia
                status (True/False).
            obesity (bool): The patient's obesity status (BMI > 30 kg/m²)
                (True/False).

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "HEART Score (integer)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_heart_score_explanation` function is used to
                calculate the HEART Score.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "age": [float(age_value), str(age_unit)],  # Age: [value, unit]
            "hypertension": bool(hypertension),  # Hypertension status
            "history": str(history),  # History of chest pain
            "diabetes_mellitus": bool(diabetes_mellitus),  # Diabetes status
            "smoking": bool(smoking),  # Smoking history
            "family_with_cvd": bool(
                family_with_cvd
            ),  # Family history of cardiovascular disease
            "atherosclerotic_disease": bool(
                atherosclerotic_disease
            ),  # Atherosclerotic disease status
            # Initial troponin level
            "initial_troponin": str(initial_troponin),
            # Electrocardiogram status
            "electrocardiogram": str(electrocardiogram),
            "hypercholesterolemia": bool(
                hypercholesterolemia
            ),  # Hypercholesterolemia status
            "obesity": bool(obesity),  # Obesity status
            "risk_factors": {},  # Risk factors dictionary
        }

        try:
            # Call the HEART Score calculation function
            from camel.toolkits.medcalc_bench.heart_score import (
                compute_heart_score_explanation,
            )

            result = compute_heart_score_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    # Final answer (HEART Score)
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_heart_score_explanation", e)

    def homa_ir(
        self,
        # Numeric part of the insulin level (e.g., 756.0)
        insulin_value: float,
        insulin_unit: str,  # Unit of the insulin level (e.g., "pmol/L")
        glucose_value: float,  # Numeric part of the glucose level (e.g., 97.3)
        glucose_unit: str,  # Unit of the glucose level (e.g., "mg/dL")
    ) -> str:
        r"""Calculate the patient's Homeostatic Model Assessment for Insulin
        Resistance (HOMA-IR) and generate a detailed explanatory text.

        Args:
            insulin_value (float): The numeric value of the patient's
                insulin level.
            insulin_unit (str): The unit of the patient's insulin level,
                one of the following:
                - "µIU/mL" for micro-international units per milliliter.
                - "pmol/L" for picomoles per liter.
                - "ng/mL" for nanograms per milliliter.
            glucose_value (float): The numeric value of the patient's
                glucose level.
            glucose_unit (str): The unit of the patient's glucose level, one
                of the following:
                - "mmol/L" for millimoles per liter.
                - "mg/dL" for milligrams per deciliter.
                - "mEq/L" for milliequivalents per liter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "HOMA-IR score (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_homa_ir_explanation` function is used to calculate
                the HOMA-IR score.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
            - If the input units are not supported, the function will not
                calculate HOMA-IR.
        """
        # Construct the input variables dictionary
        input_variables = {
            "insulin": (
                float(insulin_value),
                str(insulin_unit),
            ),  # Insulin: (value, unit)
            "glucose": (
                float(glucose_value),
                str(glucose_unit),
            ),  # Glucose: (value, unit)
        }
        print(input_variables)

        try:
            # Call the HOMA-IR calculation function
            from camel.toolkits.medcalc_bench.homa_ir import (
                compute_homa_ir_explanation,
            )

            result = compute_homa_ir_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_homa_ir_explanation", e)

    def ideal_body_weight(
        self,
        height_value: float,  # Numeric part of the height (e.g., 170)
        height_unit: str,  # Unit of the height (e.g., "cm")
        sex: str,  # Gender ("male"/"female")
        # Age (currently unused but may be used for future extensions)
        age: int,
    ) -> str:
        r"""Calculate the patient's Ideal Body Weight (IBW) and generate a
        detailed explanatory text.

        Args:
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of
                the following:
                - "cm" for centimeters.
                - "in" for inches.
            sex (str): The patient's gender, one of the following:
                - "Male" for male.
                - "Female" for female.
            age (int): The patient's age (integer). Currently unused but may
                be used for future extensions.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Ideal body weight in kilograms
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `ibw_explanation` function is used to calculate
                the ideal body weight.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
            - If the input gender is not "male" or "female", the function
                will not calculate IBW.
        """
        # Construct the input variables dictionary
        input_variables = {
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
            "sex": str(sex),  # Gender
            "age": int(age),  # Age
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.ideal_body_weight import (
            ibw_explanation,
        )

        try:
            # Call the IBW calculation function
            result = ibw_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("ibw_explanation", e)

    def mean_arterial_pressure(
        self,
        # Numeric part of the systolic blood pressure (e.g., 120.0)
        sys_bp_value: float,
        # Unit of the systolic blood pressure (e.g., "mm hg")
        sys_bp_unit: str,
        # Numeric part of the diastolic blood pressure (e.g., 80.0)
        dia_bp_value: float,
        # Unit of the diastolic blood pressure (e.g., "mm hg")
        dia_bp_unit: str,
    ) -> str:
        r"""Calculate the patient's Mean Arterial Pressure (MAP) and generate a
        detailed explanatory text.

        Args:
            sys_bp_value (float): The numeric value of the patient's systolic
                blood pressure.
            sys_bp_unit (str): The unit of the patient's systolic blood
                pressure, one of the following:
                - "mm hg" for millimeters of mercury.
            dia_bp_value (float): The numeric value of the patient's
                diastolic blood pressure.
            dia_bp_unit (str): The unit of the patient's diastolic blood
                pressure, one of the following:
                - "mm hg" for millimeters of mercury.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Mean arterial pressure in millimeters of
                        mercury (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `mean_arterial_pressure_explanation` function is used to
                calculate the mean arterial pressure.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
            - If the input units are not "mm hg", the function will not
                calculate MAP.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sys_bp": (
                float(sys_bp_value),
                str(sys_bp_unit),
            ),  # Systolic Blood Pressure: (value, unit)
            "dia_bp": (
                float(dia_bp_value),
                str(dia_bp_unit),
            ),  # Diastolic Blood Pressure: (value, unit)
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.mean_arterial_pressure import (
            mean_arterial_pressure_explanation,
        )

        try:
            # Call the MAP calculation function
            result = mean_arterial_pressure_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "mean_arterial_pressure_explanation", e
            )

    def sOsm(
        self,
        # Numeric part of the blood urea nitrogen level (e.g., 20.0)
        bun_value: float,
        bun_unit: str,  # Unit of the blood urea nitrogen level (e.g., "mg/dL")
        # Numeric part of the blood glucose level (e.g., 599.0)
        glucose_value: float,
        glucose_unit: str,  # Unit of the blood glucose level (e.g., "mg/dL")
        sodium_value: float,  # Numeric part of the sodium level (e.g., 139.0)
        sodium_unit: str,  # Unit of the sodium level (e.g., "mEq/L")
    ) -> str:
        r"""Calculate the patient's Serum Osmolality and generate a detailed
        explanatory text.

        Args:
            bun_value (float): The numeric value of the patient's blood urea
                nitrogen level.
            bun_unit (str): The unit of the patient's blood urea nitrogen
                level, one of the following:
                - "mg/dL" for milligrams per deciliter.
                - "mmol/L" for millimoles per liter.
            glucose_value (float): The numeric value of the patient's
                blood glucose level.
            glucose_unit (str): The unit of the patient's blood glucose level,
                one of the following:
                - "mg/dL" for milligrams per deciliter.
                - "mmol/L" for millimoles per liter.
            sodium_value (float): The numeric value of the patient's
                sodium level.
            sodium_unit (str): The unit of the patient's sodium level, one of
                the following:
                - "mEq/L" for milliequivalents per liter.
                - "mmol/L" for millimoles per liter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Serum osmolality in mmol/L
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_serum_osmolality_explanation` function is used to
                calculate the serum osmolality.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "bun": (float(bun_value), str(bun_unit)),  # BUN: (value, unit)
            "glucose": (
                float(glucose_value),
                str(glucose_unit),
            ),  # Glucose: (value, unit)
            "sodium": (
                float(sodium_value),
                str(sodium_unit),
            ),  # Sodium: (value, unit)
        }
        print(input_variables)

        try:
            from camel.toolkits.medcalc_bench.sOsm import (
                compute_serum_osmolality_explanation,
            )

            # Call the serum osmolality calculation function
            result = compute_serum_osmolality_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_serum_osmolality_explanation", e
            )

    def delta_gap(
        self,
        sodium_value: float,  # Numeric part of the sodium level (e.g., 135.0)
        sodium_unit: str,  # Unit of the sodium level (e.g., "mEq/L")
        # Numeric part of the chloride level (e.g., 100.0)
        chloride_value: float,
        chloride_unit: str,  # Unit of the chloride level (e.g., "mEq/L")
        # Numeric part of the bicarbonate level (e.g., 19.0)
        bicarbonate_value: float,
        bicarbonate_unit: str,  # Unit of the bicarbonate level (e.g., "mEq/L")
    ) -> str:
        r"""Calculate the patient's Delta Gap and generate a detailed
        explanatory text.

        Args:
            sodium_value (float): The numeric value of the
                patient's sodium level.
            sodium_unit (str): The unit of the patient's sodium level,
                one of the following:
                - "mEq/L" for milliequivalents per liter.
                - "mmol/L" for millimoles per liter.
            chloride_value (float): The numeric value of the patient's
                chloride level.
            chloride_unit (str): The unit of the patient's chloride level,
                one of the following:
                - "mEq/L" for milliequivalents per liter.
                - "mmol/L" for millimoles per liter.
            bicarbonate_value (float): The numeric value of the patient's
                bicarbonate level.
            bicarbonate_unit (str): The unit of the patient's bicarbonate
                level, one of the following:
                - "mEq/L" for milliequivalents per liter.
                - "mmol/L" for millimoles per liter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Delta gap in mEq/L (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_delta_gap_explanation` function is used to
                calculate the delta gap.
            - The `json.dumps` function is used to serialize the
                result into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (
                float(sodium_value),
                str(sodium_unit),
            ),  # Sodium: (value, unit)
            "chloride": (
                float(chloride_value),
                str(chloride_unit),
            ),  # Chloride: (value, unit)
            "bicarbonate": (
                float(bicarbonate_value),
                str(bicarbonate_unit),
            ),  # Bicarbonate: (value, unit)
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.delta_gap import (
            compute_delta_gap_explanation,
        )

        try:
            # Call the Delta Gap calculation function
            result = compute_delta_gap_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_delta_gap_explanation", e)

    def estimated_conception_date(
        self,
        # Length of the patient's menstrual cycle (e.g., 28)
        cycle_length: int,
        # Date of the patient's last menstrual period (e.g., "01/21/2004")
        menstrual_date: str,
    ) -> str:
        r"""Calculate the patient's estimated conception date and generate a
        detailed explanatory text.

        Args:
            cycle_length (int): The length of the patient's menstrual
                cycle in days.
            menstrual_date (str): The date of the patient's last menstrual
                period in the format "%m/%d/%Y".

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Estimated conception date in the format
                        '%m/%d/%Y' (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `add_2_weeks_explanation` function is used to calculate the
                estimated conception date.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "cycle_length": int(cycle_length),  # Cycle length in days
            "menstrual_date": str(
                menstrual_date
            ),  # Last menstrual date in the format "%m/%d/%Y"
        }
        print(input_variables)

        try:
            from camel.toolkits.medcalc_bench.estimated_conception_date import (
                add_2_weeks_explanation,
            )

            # Call the conception date calculation function
            result = add_2_weeks_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("add_2_weeks_explanation", e)

    def estimated_gestational_age(
        self,
        # Current date in the format "%m/%d/%Y" (e.g., "04/29/2022")
        current_date: str,
        # Patient's last menstrual date in the format "%m/%d/%Y" (e.g.,
        # "01/06/2022")
        menstrual_date: str,
    ) -> str:
        r"""Calculate the patient's gestational age and generate a detailed
        explanatory text.

        Args:
            current_date (str): The current date in the format "%m/%d/%Y".
            menstrual_date (str): The patient's last menstrual date in
                the format "%m/%d/%Y".

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Gestational age in weeks and days
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_gestational_age_explanation` function is used to
                calculate the gestational age.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "current_date": str(current_date),  # Current date
            "menstrual_date": str(menstrual_date),  # Last menstrual date
        }
        print(input_variables)

        try:
            from camel.toolkits.medcalc_bench.estimated_gestational_age import (
                compute_gestational_age_explanation,
            )

            # Call the gestational age calculation function
            result = compute_gestational_age_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    # Final answer (string format)
                    "final_answer": f"{result['Answer'][0]} and {result['Answer'][1]}",
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_gestational_age_explanation", e
            )

    def mdrd_gfr(
        self,
        age_value: float,  # Numeric part of the age (e.g., 49)
        age_unit: str,  # Unit of the age (e.g., "years")
        # Numeric part of the creatinine level (e.g., 10.6)
        creatinine_value: float,
        creatinine_unit: str,  # Unit of the creatinine level (e.g., "mg/dL")
        sex: str,  # Gender ("male"/"female")
        race: str = None,  # Race (optional, e.g., "Black")
    ) -> str:
        r"""Calculate the patient's Glomerular Filtration Rate (GFR) using the
        MDRD equation and generate a detailed explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, one of
                the following:
                - "years" for years.
            creatinine_value (float): The numeric value of the patient's blood
                creatinine level.
            creatinine_unit (str): The unit of the patient's blood creatinine
                level, one of the following:
                - "mg/dL" for milligrams per deciliter.
                - "µmol/L" for micromoles per liter.
            sex (str): The patient's gender, one of the following:
                - "Male" for male.
                - "Female" for female.
            race (str, optional): The patient's race, one of the following:
                - "Black" for Black.
                - Other races or unspecified will default to a coefficient
                    of 1.0.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Glomerular Filtration Rate (GFR) in
                        mL/min/1.73m² (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `mrdr_gfr_explanation` function is used to calculate the GFR.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
            - If the input gender is not "male" or "female", the function
                will not calculate GFR.
        """
        # Construct the input variables dictionary
        input_variables = {
            "age": (float(age_value), str(age_unit)),  # Age: (value, unit)
            "creatinine": (
                float(creatinine_value),
                str(creatinine_unit),
            ),  # Creatinine: (value, unit)
            "sex": str(sex),  # Gender
            "race": str(race) if race else None,  # Race (optional)
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.mdrd_gfr import mrdr_gfr_explanation

        try:
            # Call the GFR calculation function
            result = mrdr_gfr_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("mrdr_gfr_explanation", e)

    def target_weight(
        self,
        bmi_value: float,  # Numeric part of the BMI (e.g., 20.1)
        bmi_unit: str,  # Unit of the BMI (e.g., "kg/m^2")
        height_value: float,  # Numeric part of the height (e.g., 72)
        height_unit: str,  # Unit of the height (e.g., "in")
    ) -> str:
        r"""Calculate the patient's Target Weight (TW) and generate a detailed
        explanatory text.

        Args:
            bmi_value (float): The numeric value of the patient's BMI.
            bmi_unit (str): The unit of the patient's BMI, one of
                the following:
                - "kg/m^2" for kilograms per square meter.
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of
                the following:
                - "cm" for centimeters.
                - "in" for inches.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Target weight in kilograms
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `targetweight_explanation` function is used to calculate
                the target weight.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "body_mass_index": (
                float(bmi_value),
                str(bmi_unit),
            ),  # BMI: (value, unit)
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.target_weight import (
            targetweight_explanation,
        )

        try:
            # Call the Target Weight calculation function
            result = targetweight_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("targetweight_explanation", e)

    def creatinine_clearance(
        self,
        weight_value: float,  # Numeric part of the weight (e.g., 55.0)
        weight_unit: str,  # Unit of the weight ("lbs", "g", or "kg")
        height_value: float,  # Numeric part of the height (e.g., 162.8)
        height_unit: str,  # Unit of the height ("cm" or "in")
        sex: str,  # Gender ("Male" or "Female")
        creatinine_value: float,  # Numeric part of creatinine (e.g., 0.57)
        creatinine_unit: str,  # Unit of creatinine (e.g., "mg/dL")
        age_value: float,  # Numeric part of age (e.g., 16)
        age_unit: str,  # Unit of age ("years" or "months")
    ) -> str:
        r"""Calculate the patient's Creatinine Clearance using Cockcroft-Gault
        formula and generate a detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of:
                - "lbs" for pounds
                - "g" for grams
                - "kg" for kilograms
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of:
                - "cm" for centimeters
                - "in" for inches
            sex (str): The patient's gender, one of:
                - "Male" for male
                - "Female" for female
            creatinine_value (float): The numeric value of serum creatinine.
            creatinine_unit (str): The unit of serum creatinine
                (e.g., "mg/dL").
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, one of:
                - "years"
                - "months"

        Returns:
            str: A JSON string containing the calculation process
                and result, formatted as:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Creatinine clearance in mL/min
                        (string format)"
                }
                If an exception occurs, return an error message generated
                    by the `handle_exception` method.

        Notes:
            - The `generate_cockcroft_gault_explanation` function
                is used for calculation.
            - The `json.dumps` function is used to serialize the
                result into a JSON string.
            - If the input gender is not "Male" or "Female", the
                function will not calculate.
        """
        # Construct the input variables dictionary
        input_variables = {
            "weight": (float(weight_value), str(weight_unit)),
            "height": (float(height_value), str(height_unit)),
            "sex": str(sex),
            "creatinine": (float(creatinine_value), str(creatinine_unit)),
            "age": (float(age_value), str(age_unit)),
        }

        try:
            from camel.toolkits.medcalc_bench.creatinine_clearance import (
                generate_cockcroft_gault_explanation,
            )

            # Call the Cockcroft-Gault calculation function
            result = generate_cockcroft_gault_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "generate_cockcroft_gault_explanation", e
            )

    def wells_criteria_pe(
        self,
        clinical_dvt: bool,
        previous_pe: bool,
        previous_dvt: bool,
        heart_rate_value: float,
        heart_rate_unit: str,
        immobilization_for_3days: bool,
        hemoptysis: bool,
        surgery_in_past4weeks: bool,
        malignancy_with_treatment: bool,
        pe_number_one: bool,
    ) -> str:
        r"""
        Calculate the patient's Wells' Criteria for Pulmonary Embolism score
            and generate a detailed explanatory text.

        Parameters:
            clinical_dvt (bool): Clinical signs and symptoms of DVT.
            previous_pe (bool): Previous, objectively diagnosed PE.
            previous_dvt (bool): Previous, objectively diagnosed DVT.
            heart_rate_value (float): The numeric value of the
                patient's heart rate.
            heart_rate_unit (str): The unit of heart rate ("beats per minute").
            immobilization_for_3days (bool): Immobilization ≥3 days
                or surgery in previous 4 weeks.
            hemoptysis (bool): Presence of hemoptysis.
            surgery_in_past4weeks (bool): Surgery in past 4 weeks.
            malignancy_with_treatment (bool): Malignancy with treatment
                within 6 months or palliative.
            pe_number_one (bool): PE is #1 diagnosis or equally likely.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Wells' score for pulmonary embolism
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `calculate_pe_wells_explanation` function is used to
                calculate the Wells' score.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "clinical_dvt": bool(clinical_dvt),
            "previous_pe": bool(previous_pe),
            "previous_dvt": bool(previous_dvt),
            "heart_rate": (float(heart_rate_value), str(heart_rate_unit)),
            "immobilization_for_3days": bool(immobilization_for_3days),
            "hemoptysis": bool(hemoptysis),
            "surgery_in_past4weeks": bool(surgery_in_past4weeks),
            "malignancy_with_treatment": bool(malignancy_with_treatment),
            "pe_number_one": bool(pe_number_one),
        }
        try:
            from camel.toolkits.medcalc_bench.wells_criteria_pe import (
                calculate_pe_wells_explanation,
            )

            # Call the Wells' score calculation function
            result = calculate_pe_wells_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result['Explanation'],
                    "final_answer": str(result['Answer']),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("calculate_pe_wells_explanation", e)

    def ldl_calculated(
        self,
        hdl_value: float,  # Numeric part of HDL cholesterol (e.g., 37.0)
        hdl_unit: str,  # Unit of HDL cholesterol (e.g., "mg/dL")
        triglycerides_value: float,  # Numeric part of triglycerides (e.g., 205.0)
        triglycerides_unit: str,  # Unit of triglycerides (e.g., "mg/dL")
        total_value: float,  # Numeric part of total cholesterol (e.g., 210.0)
        total_unit: str,  # Unit of total cholesterol (e.g., "mg/dL")
    ) -> str:
        """
        Calculate the patient's LDL cholesterol concentration and generate a detailed explanatory text.

        Parameters:
            hdl_value (float): The numeric value of the patient's HDL cholesterol.
            hdl_unit (str): The unit of the patient's HDL cholesterol, one of the following:
                - "mg/dL" for milligrams per deciliter
                - "mmol/L" for millimoles per liter
                - Other supported cholesterol concentration units
            triglycerides_value (float): The numeric value of the patient's triglycerides.
            triglycerides_unit (str): The unit of the patient's triglycerides, one of the following:
                - "mg/dL" for milligrams per deciliter
                - "mmol/L" for millimoles per liter
                - Other supported triglyceride concentration units
            total_value (float): The numeric value of the patient's total cholesterol.
            total_unit (str): The unit of the patient's total cholesterol, one of the following:
                - "mg/dL" for milligrams per deciliter
                - "mmol/L" for millimoles per liter
                - Other supported cholesterol concentration units

        Returns:
            str: A JSON string containing the calculation process and result, formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory text",
                    "final_answer": "LDL cholesterol concentration in mg/dL (string format)"
                }
                If an exception occurs, return an error message generated by the `handle_exception` method.

        Notes:
            - The `compute_ldl_explanation` function is used to calculate the LDL cholesterol.
            - The `json.dumps` function is used to serialize the result into a JSON string.
            - The calculation uses the formula: LDL = total cholesterol - HDL - (triglycerides / 5)
            - All values are converted to mg/dL for the calculation.
        """
        # Construct the input variables dictionary
        input_variables = {
            "hdl_cholestrol": (float(hdl_value), str(hdl_unit)),
            "triglycerides": (
                float(triglycerides_value),
                str(triglycerides_unit),
            ),
            "total_cholestrol": (float(total_value), str(total_unit)),
        }
        print(input_variables)

        from camel.toolkits.medcalc_bench.ldl_calculated import (
            compute_ldl_explanation,
        )

        try:
            # Call the LDL calculation function
            result = compute_ldl_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result['Explanation'],  # Detailed explanation
                    "final_answer": str(
                        result['Answer']
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_ldl_explanation", e)

    def albumin_corrected_anion(
        self,
        sodium_value: float,  # Numeric part of sodium level (e.g., 134.0)
        sodium_unit: str,  # Unit of sodium level (e.g., "mmol/L")
        chloride_value: float,  # Numeric part of chloride level (e.g., 100.0)
        chloride_unit: str,  # Unit of chloride level (e.g., "mmol/L")
        bicarbonate_value: float,  # Numeric part of bicarbonate (e.g., 19.0)
        bicarbonate_unit: str,  # Unit of bicarbonate (e.g., "mmol/L")
        albumin_value: float,  # Numeric part of albumin (e.g., 4.4)
        albumin_unit: str,  # Unit of albumin (e.g., "g/dL")
    ) -> str:
        r"""Calculate the patient's Albumin Corrected Anion Gap (ACAG) and generate
        a detailed explanatory text.

        Args:
            sodium_value (float): The numeric value of sodium level.
            sodium_unit (str): The unit of sodium level, one of:
                - "mmol/L" for millimoles per liter
                - "mEq/L" for milliequivalents per liter
            chloride_value (float): The numeric value of chloride level.
            chloride_unit (str): The unit of chloride level, one of:
                - "mmol/L" for millimoles per liter
                - "mEq/L" for milliequivalents per liter
            bicarbonate_value (float): The numeric value of bicarbonate level.
            bicarbonate_unit (str): The unit of bicarbonate level, one of:
                - "mmol/L" for millimoles per liter
                - "mEq/L" for milliequivalents per liter
            albumin_value (float): The numeric value of albumin concentration.
            albumin_unit (str): The unit of albumin concentration, one of:
                - "g/dL" for grams per deciliter
                - "g/L" for grams per liter
                - "mg/dL" for milligrams per deciliter

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory text",
                    "final_answer": "Albumin corrected anion gap (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_albumin_corrected_anion_explanation` function is used
                for calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (float(sodium_value), str(sodium_unit)),
            "chloride": (float(chloride_value), str(chloride_unit)),
            "bicarbonate": (float(bicarbonate_value), str(bicarbonate_unit)),
            "albumin": (float(albumin_value), str(albumin_unit)),
        }

        from camel.toolkits.medcalc_bench.albumin_corrected_anion import (
            compute_albumin_corrected_anion_explanation,
        )

        try:
            # Call the ACAG calculation function
            result = \
                compute_albumin_corrected_anion_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(result["Answer"]),  # Final answer
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_albumin_corrected_anion_explanation", e
            )
        
    def albumin_corrected_delta_gap(
        self,
        sodium_value: float,  # Numeric part of sodium level (e.g., 141.0)
        sodium_unit: str,  # Unit of sodium level (e.g., "mEq/L")
        chloride_value: float,  # Numeric part of chloride level (e.g., 104.0)
        chloride_unit: str,  # Unit of chloride level (e.g., "mEq/L")
        bicarbonate_value: float,  # Numeric part of bicarbonate (e.g., 29.0)
        bicarbonate_unit: str,  # Unit of bicarbonate level (e.g., "mEq/L")
        albumin_value: float,  # Numeric part of albumin (e.g., 43.0)
        albumin_unit: str,  # Unit of albumin level (e.g., "g/L")
    ) -> str:
        r"""Calculate the patient's Albumin Corrected Delta Gap and generate a
        detailed explanatory text.

        Args:
            sodium_value (float): The numeric value of sodium level.
            sodium_unit (str): The unit of sodium level, one of:
                - "mEq/L" for milliequivalents per liter
                - "mmol/L" for millimoles per liter
            chloride_value (float): The numeric value of chloride level.
            chloride_unit (str): The unit of chloride level, one of:
                - "mEq/L" for milliequivalents per liter
                - "mmol/L" for millimoles per liter
            bicarbonate_value (float): The numeric value of bicarbonate level.
            bicarbonate_unit (str): The unit of bicarbonate level, one of:
                - "mEq/L" for milliequivalents per liter
                - "mmol/L" for millimoles per liter
            albumin_value (float): The numeric value of albumin level.
            albumin_unit (str): The unit of albumin level, one of:
                - "g/L" for grams per liter
                - "g/dL" for grams per deciliter
                - "mg/dL" for milligrams per deciliter

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Albumin corrected delta gap
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_albumin_corrected_delta_gap_explanation` function is
                used for calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (float(sodium_value), str(sodium_unit)),
            "chloride": (float(chloride_value), str(chloride_unit)),
            "bicarbonate": (float(bicarbonate_value), str(bicarbonate_unit)),
            "albumin": (float(albumin_value), str(albumin_unit)),
        }

        from camel.toolkits.medcalc_bench.albumin_corrected_delta_gap import (
            compute_albumin_corrected_delta_gap_explanation,
        )

        try:
            # Call the calculation function
            result = compute_albumin_corrected_delta_gap_explanation(
                input_variables
            )

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(  # Final answer (string format)
                        result["Answer"]
                    ),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_albumin_corrected_delta_gap_explanation", e
            )

    def albumin_delta_ratio(
        self,
        sodium_value: float,  # Numeric part of sodium level (e.g., 140.0)
        sodium_unit: str,  # Unit of sodium level (e.g., "mEq/L")
        chloride_value: float,  # Numeric part of chloride level (e.g., 105.0)
        chloride_unit: str,  # Unit of chloride level (e.g., "mEq/L")
        bicarbonate_value: float,  # Numeric part of bicarbonate (e.g., 28.0)
        bicarbonate_unit: str,  # Unit of bicarbonate (e.g., "mEq/L")
        albumin_value: float,  # Numeric part of albumin (e.g., 3.9)
        albumin_unit: str,  # Unit of albumin (e.g., "g/dL")
    ) -> str:
        r"""Calculate the patient's albumin delta ratio and generate a detailed
        explanatory text.

        Args:
            sodium_value (float): The numeric value of sodium level.
            sodium_unit (str): The unit of sodium level, one of:
                - "mmol/L"
                - "mEq/L"
            chloride_value (float): The numeric value of chloride level.
            chloride_unit (str): The unit of chloride level, one of:
                - "mmol/L"
                - "mEq/L"
            bicarbonate_value (float): The numeric value of bicarbonate level.
            bicarbonate_unit (str): The unit of bicarbonate level, one of:
                - "mmol/L"
                - "mEq/L"
            albumin_value (float): The numeric value of albumin concentration.
            albumin_unit (str): The unit of albumin concentration, one of:
                - "g/dL"
                - "g/L"
                - "mg/dL"
                - "g/mL"

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Albumin delta ratio (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_albumin_delta_ratio_explanation` function is used for
                the calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (float(sodium_value), str(sodium_unit)),
            "chloride": (float(chloride_value), str(chloride_unit)),
            "bicarbonate": (float(bicarbonate_value), str(bicarbonate_unit)),
            "albumin": (float(albumin_value), str(albumin_unit)),
        }

        from camel.toolkits.medcalc_bench.albumin_delta_ratio import (
            compute_albumin_delta_ratio_explanation,
        )

        try:
            # Call the calculation function
            result = compute_albumin_delta_ratio_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(  # Final answer (string format)
                        result["Answer"]
                    ),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("albumin_delta_ratio", e)

    def estimated_due_date(
        self,
        cycle_length: int,  # Patient's menstrual cycle length in days
        menstrual_date: str,  # Last menstrual date in format "%m/%d/%Y"
    ) -> str:
        r"""Calculate the patient's estimated due date and generate a detailed
        explanatory text using Naegele's Rule.

        Args:
            cycle_length (int): The length of the patient's menstrual cycle in
                days (e.g., 28).
            menstrual_date (str): The patient's last menstrual date in the
                format "MM/DD/YYYY" (e.g., "09/17/2011").

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Estimated due date in MM/DD/YYYY format"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - Uses Naegele's Rule: adds 40 weeks to menstrual date and adjusts
                based on cycle length difference from 28 days.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "cycle_length": int(cycle_length),
            "menstrual_date": str(menstrual_date),
        }

        try:
            from camel.toolkits.medcalc_bench.estimated_due_date import (
                add_40_weeks_explanation
            )

            # Call the due date calculation function
            result = add_40_weeks_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(result["Answer"]),  # Final answer
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("estimated_due_date", e)

    def free_water_deficit(
        self,
        weight_value: float,  # Numeric part of weight (e.g., 33.0)
        weight_unit: str,  # Unit of weight ("lbs", "g", "kg")
        height_value: float,  # Numeric part of height (unused in calculation)
        height_unit: str,  # Unit of height (unused in calculation)
        sex: str,  # Gender ("male"/"female")
        age_value: float,  # Numeric part of age (e.g., 32)
        age_unit: str,  # Unit of age ("years"/"months")
        sodium_value: float,  # Numeric sodium level (e.g., 134.0)
        sodium_unit: str,  # Sodium unit ("mmol/L", "mEq/L")
    ) -> str:
        r"""Calculate the patient's Free Water Deficit (FWD) and generate a
        detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of:
                - "lbs" for pounds
                - "g" for grams
                - "kg" for kilograms
            height_value (float): The numeric value of height (unused).
            height_unit (str): The unit of height (unused).
            sex (str): The patient's gender, one of:
                - "Male" for male
                - "Female" for female
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, one of:
                - "months"
                - "years"
            sodium_value (float): The numeric value of sodium level.
            sodium_unit (str): The unit of sodium level, one of:
                - "mmol/L"
                - "mEq/L"

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process text",
                    "final_answer": "Free water deficit in liters (string)"
                }
                If an exception occurs, returns an error message generated by
                the `handle_exception` method.

        Notes:
            - The `free_water_deficit_explanation` function is used for calculation.
            - The `json.dumps` function serializes the result into JSON string.
            - If input gender is not "male" or "female", function won't calculate.
        """
        # Construct input variables dictionary
        input_variables = {
            "weight": (float(weight_value), str(weight_unit)),
            "height": (float(height_value), str(height_unit)),
            "sex": str(sex),
            "age": (float(age_value), str(age_unit)),
            "sodium": (float(sodium_value), str(sodium_unit)),
        }

        from camel.toolkits.medcalc_bench.free_water_deficit import (
            free_water_deficit_explanation,
        )

        try:
            # Call the FWD calculation function
            result = free_water_deficit_explanation(input_variables)

            # Return result as JSON string
            return json.dumps({
                "rationale": result["Explanation"],
                "final_answer": str(result["Answer"]),
            })

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception("free_water_deficit_explanation", e)

    def glasgow_coma_score(
        self,
        best_eye_response: str,  # Patient's best eye response
        best_verbal_response: str,  # Patient's best verbal response
        best_motor_response: str,  # Patient's best motor response
    ) -> str:
        r"""Calculate the patient's Glasgow Coma Score (GCS) and generate a
        detailed explanatory text.

        Args:
            best_eye_response (str): The patient's best eye response, one of:
                - "eyes open spontaneously"
                - "eye opening to verbal command"
                - "eye opening to pain"
                - "no eye opening"
                - "not testable"
            best_verbal_response (str): The patient's best verbal
                response, one of:
                - "oriented"
                - "confused"
                - "inappropriate words"
                - "incomprehensible sounds"
                - "no verbal response"
                - "not testable"
            best_motor_response (str): The patient's best motor response,
                one of:
                - "obeys commands"
                - "localizes pain"
                - "withdrawal from pain"
                - "flexion to pain"
                - "extension to pain"
                - "no motor response"

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Glasgow Coma Score (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `compute_glasgow_coma_score_explanation` function is used to
                calculate the score.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "best_eye_response": str(best_eye_response),
            "best_verbal_response": str(best_verbal_response),
            "best_motor_response": str(best_motor_response),
        }

        try:
            from camel.toolkits.medcalc_bench.glasgow_coma_score import (
                compute_glasgow_coma_score_explanation,
            )
            # Call the GCS calculation function
            result = compute_glasgow_coma_score_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(  # Final answer (string format)
                        result["Answer"]
                    ),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_glasgow_coma_score", e)

    def qt_calculator_bazett(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 176)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_interval_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_interval_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate the patient's corrected QT interval using
            Bazett Formula and generate a detailed explanatory text.

        Args:
            heart_rate_value (float): The numeric value of heart rate.
            heart_rate_unit (str): The unit of heart rate, must be:
                - "beats per minute"
            qt_interval_value (float): The numeric value of QT interval.
            qt_interval_unit (str): The unit of QT interval, must be:
                - "msec" for milliseconds

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Corrected QT interval in
                        msec (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `bazett_calculator_explanation` function is
                used for calculation.
            - The `json.dumps` function serializes
                the result into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # Heart rate: (value, unit)
            "qt_interval": (
                float(qt_interval_value),
                str(qt_interval_unit),
            ),  # QT interval: (value, unit)
        }

        from camel.toolkits.medcalc_bench.qt_calculator_bazett import (
            bazett_calculator_explanation,
        )

        try:
            # Call the Bazett calculation function
            result = bazett_calculator_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("bazett_calculator_explanation", e)
        
    def qt_calculator_framingham(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 81)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_interval_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_interval_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate patient's corrected QT interval using Framingham Formula and
        generate detailed explanatory text.

        Args:
            heart_rate_value (float): Numeric value of patient's heart rate.
            heart_rate_unit (str): Unit of heart rate, must be:
                - "beats per minute"
            qt_interval_value (float): Numeric value of QT interval.
            qt_interval_unit (str): Unit of QT interval, must be:
                - "msec" for milliseconds.

        Returns:
            str: JSON string containing calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process text",
                    "final_answer": "Corrected QT interval (string format)"
                }
                If exception occurs, returns error message from handle_exception.

        Notes:
            - Uses framingham_calculator_explanation for calculation.
            - Uses json.dumps to serialize result into JSON string.
        """
        # Construct input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # Heart rate: (value, unit)
            "qt_interval": (
                float(qt_interval_value),
                str(qt_interval_unit),
            ),  # QT interval: (value, unit)
        }

        from camel.toolkits.medcalc_bench.qt_calculator_framingham import (
            framingham_calculator_explanation,
        )

        try:
            # Call the Framingham calculation function
            result = framingham_calculator_explanation(input_variables)

            # Return result as JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception("qt_calculator_framingham", e)

    def qt_calculator_fredericia(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 70)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate the patient's corrected QT interval using
        Fridericia Formula and generate a detailed explanatory text.

        Args:
            heart_rate_value (float): The numeric value of heart rate.
            heart_rate_unit (str): The unit of heart rate, should be:
                - "beats per minute"
            qt_value (float): The numeric value of QT interval.
            qt_unit (str): The unit of QT interval, should be:
                - "msec" for milliseconds.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Corrected QT interval
                        in msec (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `fredericia_calculator_explanation` function is used for the
                calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # Heart rate: (value, unit)
            "qt_interval": (
                float(qt_value),
                str(qt_unit),
            ),  # QT interval: (value, unit)
        }

        from camel.toolkits.medcalc_bench.qt_calculator_fredericia import (
            fredericia_calculator_explanation,
        )

        try:
            # Call the QT correction calculation function
            result = fredericia_calculator_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("qt_calculator_fredericia", e)
        
    def qt_calculator_hodges(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 52)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_interval_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_interval_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate the patient's corrected QT interval (QTc) using Hodges formula
        and generate a detailed explanatory text.

        Args:
            heart_rate_value (float): The numeric value of patient's heart rate.
            heart_rate_unit (str): The unit of heart rate, must be:
                - "beats per minute"
            qt_interval_value (float): The numeric value of QT interval.
            qt_interval_unit (str): The unit of QT interval, must be:
                - "msec" for milliseconds.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Corrected QT interval in msec (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `hodges_calculator_explanation` function is used to calculate the
                corrected QT interval.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # Heart rate: (value, unit)
            "qt_interval": (
                float(qt_interval_value),
                str(qt_interval_unit),
            ),  # QT interval: (value, unit)
        }

        from camel.toolkits.medcalc_bench.qt_calculator_hodges import (
            hodges_calculator_explanation,
        )

        try:
            # Call the QTc calculation function
            result = hodges_calculator_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("hodges_calculator_explanation", e)

    def qt_calculator_rautaharju(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 110)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_interval_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_interval_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate patient's corrected QT interval
            using Rautaharju formula and generate detailed explanatory text.

        Args:
            heart_rate_value (float): Numeric value of patient's heart rate.
            heart_rate_unit (str): Unit of heart rate, must be:
                - "beats per minute"
            qt_interval_value (float): Numeric value of QT interval.
            qt_interval_unit (str): Unit of QT interval, must be:
                - "msec"

        Returns:
            str: JSON string containing calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Corrected QT interval in msec (string)"
                }
                If exception occurs, returns error message
                    from handle_exception.

        Notes:
            - Uses Rautaharju formula: QTc = QT × (120 + HR) / 180
            - The `json.dumps` function serializes result into JSON string.
            - Units must match expected values or calculation will fail.
        """
        # Construct input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # (value, unit)
            "qt_interval": (
                float(qt_interval_value),
                str(qt_interval_unit),
            ),  # (value, unit)
        }

        from camel.toolkits.medcalc_bench.qt_calculator_rautaharju import (
            rautaharju_calculator_explanation,
        )

        try:
            # Call QT calculation function
            result = rautaharju_calculator_explanation(input_variables)

            # Return result as JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception("rautaharju_calculator_explanation", e)

    def steroid_conversion_calculator(
        self,
        input_steroid: str,  # Input steroid with route (e.g., "Hydrocortisone PO")
        input_value: float,  # Numeric value of input steroid (e.g., 190.936)
        input_unit: str,  # Unit of input steroid (e.g., "mg")
        target_steroid: str,  # Target steroid with route (e.g., "MethylPrednisoLONE IV")
    ) -> str:
        r"""Calculate equivalent dosage of target steroid and generate explanatory
        text.

        Args:
            input_steroid (str): Input steroid name with route, one of:
                - "Betamethasone IV"
                - "Cortisone PO"
                - "Dexamethasone IV"
                - "Dexamethasone PO"
                - "Hydrocortisone IV"
                - "Hydrocortisone PO"
                - "MethylPrednisoLONE IV"
                - "MethylPrednisoLONE PO"
                - "PrednisoLONE PO"
                - "PredniSONE PO"
                - "Triamcinolone IV"
            input_value (float): Numeric value of input steroid dose.
            input_unit (str): Unit of input steroid dose (e.g., "mg").
            target_steroid (str): Target steroid name with route, one of:
                - "Betamethasone IV"
                - "Cortisone PO"
                - "Dexamethasone IV"
                - "Dexamethasone PO"
                - "Hydrocortisone IV"
                - "Hydrocortisone PO"
                - "MethylPrednisoLONE IV"
                - "MethylPrednisoLONE PO"
                - "PrednisoLONE PO"
                - "PredniSONE PO"
                - "Triamcinolone IV"

        Returns:
            str: A JSON string containing calculation process and result, formatted:
                {
                    "rationale": "Detailed calculation process and explanation",
                    "final_answer": "Equivalent dosage in mg (string format)"
                }
                If an exception occurs, returns error message from
                `handle_exception` method.

        Notes:
            - Uses `compute_steroid_conversion_explanation` for calculation.
            - Uses `json.dumps` to serialize result into JSON string.
            - Both input and target steroids must include route (IV/PO).
        """
        input_variables = {
            "input steroid": [str(input_steroid), float(input_value), str(input_unit)],
            "target steroid": str(target_steroid),
        }

        from camel.toolkits.medcalc_bench.steroid_conversion_calculator import (
            compute_steroid_conversion_explanation,
        )

        try:
            result = compute_steroid_conversion_explanation(input_variables)
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )
        except Exception as e:
            return self.handle_exception("steroid_conversion", e)
        
    def wells_criteria_dvt(
        active_cancer: bool,  # Active cancer treatment within 6 months
        bedridden_for_atleast_3_days: bool,  # Bedridden >3 days recently
        major_surgery_in_last_12_weeks: bool,  # Major surgery within 12 weeks
        calf_swelling_3cm: bool,  # Calf swelling >3 cm vs other leg
        collateral_superficial_veins: bool,  # Collateral superficial veins
        leg_swollen: bool,  # Entire leg swollen
        localized_tenderness_on_deep_venuous_system: bool,  # Tenderness
        pitting_edema_on_symptomatic_leg: bool,  # Pitting edema in symptomatic leg
        paralysis_paresis_immobilization_in_lower_extreme: bool,  # Immobilization
        previous_dvt: bool,  # Previously documented DVT
        alternative_to_dvt_diagnosis: bool,  # Alternative diagnosis more likely
    ) -> str:
        r"""Calculate the patient's Wells' Criteria for DVT score and generate a
        detailed explanatory text.

        Args:
            active_cancer (bool): Active cancer treatment within 6 months.
            bedridden_for_atleast_3_days (bool): Bedridden >3 days recently.
            major_surgery_in_last_12_weeks (bool): Major surgery within 12 weeks.
            calf_swelling_3cm (bool): Calf swelling >3 cm vs other leg.
            collateral_superficial_veins (bool): Collateral superficial veins.
            leg_swollen (bool): Entire leg swollen.
            localized_tenderness_on_deep_venuous_system (bool): Tenderness.
            pitting_edema_on_symptomatic_leg (bool): Pitting edema in symptomatic leg.
            paralysis_paresis_immobilization_in_lower_extreme (bool): Immobilization.
            previous_dvt (bool): Previously documented DVT.
            alternative_to_dvt_diagnosis (bool): Alternative diagnosis more likely.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory text",
                    "final_answer": "Wells' Criteria for DVT score (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `compute_wells_criteria_dvt_explanation` function is used for
            the actual calculation.
            - The `json.dumps` function is used to serialize the result into JSON.
        """
        # Construct the input variables dictionary
        input_variables = {
            "active_cancer": bool(active_cancer),
            "bedridden_for_atleast_3_days": bool(bedridden_for_atleast_3_days),
            "major_surgery_in_last_12_weeks": bool(major_surgery_in_last_12_weeks),
            "calf_swelling_3cm": bool(calf_swelling_3cm),
            "collateral_superficial_veins": bool(collateral_superficial_veins),
            "leg_swollen": bool(leg_swollen),
            "localized_tenderness_on_deep_venuous_system": bool(
                localized_tenderness_on_deep_venuous_system
            ),
            "pitting_edema_on_symptomatic_leg": bool(
                pitting_edema_on_symptomatic_leg
            ),
            "paralysis_paresis_immobilization_in_lower_extreme": bool(
                paralysis_paresis_immobilization_in_lower_extreme
            ),
            "previous_dvt": bool(previous_dvt),
            "alternative_to_dvt_diagnosis": bool(alternative_to_dvt_diagnosis),
        }

        from camel.toolkits.medcalc_bench.wells_criteria_dvt import (
            compute_wells_criteria_dvt_explanation,
        )

        try:
            # Call the Wells' Criteria calculation function
            result = compute_wells_criteria_dvt_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_wells_criteria_dvt_explanation", e)

    def handle_exception(self, func_name: str, error: Exception) -> str:
        r"""Handles exceptions by logging the error and returning
            a standardized error message.

        Args:
            func_name (str): The name of the function where
                the exception occurred.
            error (Exception): The exception object containing
                details about the error.

        Returns:
            str: A JSON string containing the following fields:
                - "status" (str): Always set to `"error"`.
                - "message" (str): A human-readable description of the error.
        """
        logger.error(f"Error in {func_name}: {error}")
        return json.dumps(
            {"status": "error", "message": f"Error in {func_name}: {error}"},
            ensure_ascii=False,
        )

    def get_tools(self) -> List[FunctionTool]:
        r"""Exposes the tool's methods to the agent framework.

        Returns:
            List[FunctionTool]: A list of `FunctionTool` objects representing
                the toolkit's methods, making them accessible to the agent.
        """
        return [
            FunctionTool(self.adjusted_body_weight),
            FunctionTool(self.anion_gap),
            FunctionTool(self.bmi_calculator),
            FunctionTool(self.bsa_calculator),
            FunctionTool(self.calcium_correction),
            FunctionTool(self.delta_gap),
            FunctionTool(self.estimated_conception_date),
            FunctionTool(self.estimated_gestational_age),
            FunctionTool(self.feverpain),
            FunctionTool(self.heart_score),
            FunctionTool(self.homa_ir),
            FunctionTool(self.ideal_body_weight),
            FunctionTool(self.mdrd_gfr),
            FunctionTool(self.mean_arterial_pressure),
            FunctionTool(self.sOsm),
            FunctionTool(self.target_weight),
            FunctionTool(self.creatinine_clearance),
            FunctionTool(self.wells_criteria_pe),
            FunctionTool(self.ldl_calculated),
            FunctionTool(self.albumin_corrected_anion),
            FunctionTool(self.albumin_corrected_delta_gap),
            FunctionTool(self.albumin_delta_ratio),
            FunctionTool(self.estimated_due_date),
            FunctionTool(self.free_water_deficit),
            FunctionTool(self.glasgow_coma_score),
            FunctionTool(self.qt_calculator_bazett),
            FunctionTool(self.qt_calculator_framingham),
            FunctionTool(self.qt_calculator_fredericia),
            FunctionTool(self.qt_calculator_hodges),
            FunctionTool(self.qt_calculator_rautaharju),
            FunctionTool(self.steroid_conversion_calculator),
            FunctionTool(self.wells_criteria_dvt)
        ]
